# 编码相关

**代码**

* 代码结构、边写习惯：
* 复用度不高、扩展性不好的抽象要废弃，只有一个判定条件还用模版模式其实没有任何用户，只会多生成对象；
* final类、方法的使用：编译器编译期优化会对final方法进行内联，其对于运行效率提升比较大。
* 不需要重用的内容尽量采用局部变量，随方法的压栈弹出已经释放，不需要垃圾回收。
* 集合类初始大小的使用。在可以确定集合类的大小的情况下，尽量在声明的时候就设置大小。比如HashMap的默认大小是16，如果size比较大，多次resize的成本很高。
* 不要在循环中反复获取同一个资源，比如：\(for int i =0; i &lt; a.size\(\); i++\),可以考虑将a.size\(\)提取到外面或者在声明i的地方）。
* 不要再循环内trycatch；
* 如果可以的话，乘除算法可以考虑使用移位操作，但是这样子可读性会变差。
* 昂贵、重复访问资源使用方式：
* 预初始化：不论是采用静态加载，还是在构造方法里面初始化，还是采用postconstruct等注解加载，对于读取次数很多的内容，如果某单位时间内变动次数很少，或者可以采用广播、通知方式更新的内容，都可以先在内存进行初始化。
* 懒加载：不论是接口调用，还是某些值的调用。如果在代码抽象后，需要前后访问，并且在一定条件下才可以访问，可以考虑采用lazy的方式。该情况主要应对于需要对外的调用，db、缓存、接口等都可以看情况进行。
* 异步计算：该内容不是指多线程并发。仅仅是指某些需要计算的内容的，可以通过单独某个线程、其他应用进行计算其结果，然后逻辑直接访问，而不是每次都计算。
* 锁争抢的缩小：
* 线程私有变量的使用，比如threadlocalrandom、pattern（regrex）；
* 机器之间的逻辑按照锁的维度将固定的值路由stick到固定机器，可以合并消息处理，避免分布锁的争抢；
* 重复执行的代码进行缓存，比如int的127
* 资源操作的合并：
* 多insert改为batch insert；
* redis多次get改为mget或者pipeline方式；
* 日志、埋点上报的本地缓存，批量上报；
* vm间需要获取分布式锁资源的操作，可以考虑vm间该锁粒度的内容都stick到同一台机器，减少锁争抢。
* 日志打印
* 比如接口超时日志如果仅作为指标其实可以抽样或者合并异常打印，其实对于GC的优化也有帮助。
* 日志级别只打印需要的级别，日志过多对于高qps的应用压力非常大。
* 打印时日志级别的判定，先ifxxxenabled，再打印，否则即便是日志级别没有那么低，其实也会先执行
* log4j2 替换log4j等，asyncappender的使用等。
* 多线程的合理使用：
* 并行化调用，比如某个接口单词允许200个大小的list当入参，但是我们有1000个参数，循环5次VS并行5个线程；
* 基本上使用线程的场景（除非是jvm钩子），一般都需要使用线程池；
* 线程池的资源很宝贵，需要在使用的时候估计好线程数量、线程工厂、队列大小、拒绝策略等，不要随便就声明了池资源。
* 线程间通信使用并发包的各种工具，semaphore、countdownlatch等，不要自己造全局变量再加锁。
* 对于线程不安全但是线程内逻辑可服用的，尽量采用threadlocal变量，而不要全局变量加锁。
* 事务缩小：
* 主逻辑中分支逻辑进行异步化，保证最终一致性；
* 采用消息通知等通知到细分服务逻辑，巨大的逻辑事务可以考虑拆分服务，消息通知、消息流等。
* 缓存的使用：
* 集群缓存引入：结果不变，vo缓存 VS 结果拼接，dao缓存；
* 缓存qps很高的情况下，数据体拉平：序列化压力大的场景情况下，缓存可以考虑数据体的拉平缩小；
* 合理使用redis的各种结构；
* 锁的ttl（timetoleave）失效打散，否则集中失效会导致集群性能变差；
* 纯内存服务（理论上性能最好的选择，但是一致性维护成本很高）：
* 通过mq或者自己写的广播实现内存刷新；
* 布隆过滤器的使用；
* 计算数据体大小和vm的配置，推荐直接进入老年代；
* IO：
* 使用非阻塞IO，NIO的使用；
* 异常使用：
* 异常抛出后，vm需要调整调用堆栈，对于性能影响较大，所以要慎用异常；
* 异常使用准确的内容，不要每个地方都是直接使用Exception捕捉。
* 反射：
* 若非必要，尽量少采用反射；特别是还需要通过反射去获取一个类的资源，这个操作比较重。    i

