---
description: 后端（JAVA）开发的点滴记录与经验分享
---

# 性能优化经验

##“性能优化”的认识
以开发的视角来看：  
**性能**的直观理解其实就是计算机去执行一个任务，从发起到完成的耗时情况的表现。  
**性能优化**的话，其实无非就是提高应用性能、降低资源消耗、解决吞吐瓶颈、提升用户体验等。  
我们以分布式部署的java应用来看，其实我们按照上面的性能定义，其实我们的任务大致包含以下步骤：

1. client端发起请求
2. 服务发现
3. 服务调度
4. server端接受请求
5. server调起各种资源处理请求
6. server执行完成，返回结果

这个过程中，我们从软硬件资源相关来看，经常用得到的大概有：

* 硬件资源相关
  * 计算机资源：物理机、虚拟机、容器等
  * 路由：F5、LVS等
  * CDN
  * ······
* 软件资源相关
  * 服务治理相关：Dubbo、Spring Cloud 等
  * 缓存相关：Redis、MemCache、Tair
  * 数据库：MySql、Oracle还其他比较流行的Posgrasql等
  * 消息队列：RabbitMQ、ZeroMq、Kafka等
  * 搜索相关：ES
  * JAVA应用本身
  * ······

如果是大点的公司，中间件组可能还有日志相关的组件（比如FLK）、监控组件（各种埋点的上报）等等。

所以我们的性能优化点，其实是从两个方向出发，第一个是找出任务执行链路中的的瓶颈。其实优化的时候有一个很重要的原则就是**不要试图去优化一些本来就消耗很低的点**。某个请求响应时间100ms，其中1ms花在某复杂对象的序列化上面，有80ms花在网络传输上，还有其他10多ms在执行代码逻辑。那么我们到底是从1ms出发，还是从80ms出发时显而易见的。第二个才是对症下药，切莫病急乱投医，随便乱猜就开始优化。

按照我们目前的计算机软硬件执行情况来看，最慢的是网络请求，最快的内存（其实是主存）请求。一般我们分析的话，尽量采用从大到小，从高到低的消耗来排查服务瓶颈情况。

  - **部署**：client在A机房，server在B机房。那么我们可以优化的方向可以有: 
     * (1) A、B两个机器间的网络;比如上海调用北京，即便是专线，来回也得消耗60ms左右，所以我们应该保证同地域优先部署。甚至说我们可以使用traceroute去查看请求的路由情况，看下是否出现非必要的路径。
     * (2) A、B服务的部署拓扑；我们根据网络情况的部署拓扑大概可以按照：同机柜、同机房、同IDC、同地域、跨地域专线、跨地域普通路由等优先级逐步去进行服务的拓扑部署或者路由策略（由于运维经验不足，里面的内容若不专业还请指出）。
     * (3) 服务内逻辑部署拆分。服务容量满了，单机各种业务混合，可以考虑拆分服务，单个功能瓶颈影响到其他功能。
  - **应用机器**：这个稍微多讲一点内容。不论是物理机、虚拟机还是容器，分布式方式的水平部署，主要有以下三种方式的策略：
     * **加机器**：这个是最常见的办法了，服务有瓶颈，老王你去申请个机器加上。如果应用的服务器比较少，当前服务治理方面不存在水平扩容的压力，其实这个是最简单的方式了，适用于“大搞快上”的迭代情况。
     * **换机器**：更换机器这个讲究还挺多的。需要对于当前应用的场景进行分析。
        * cpu压力大，线程数量大 = cpu core要多；
        * 网卡读写压力大 = 网卡换好的；
        * 磁盘读写操作集中 = sas换ssd，ssd换pcie（其实这些内容在部署数据库这种应用的时候，性能差别很大）；
        * vm的压力主要在于公司的虚拟机或者容器隔离技术不够完善，同物理机的vm比如cpu.steal严重 = server应用与抢占资源的其他应用分开部署。
     * **下机器**： 这个稍微有点不常见，压力大还下机器·····其实这个主要应对于我们出现多应用间资源争抢的问题。如果在单机逻辑处理压力不大，但是任务间因为各种分布式锁等资源争抢导致吞吐下降，那么下机器可能会有帮助。
  - **中间件相关** （待补充）
     * MQ：kafka和mq的使用场景，待补充；
     * 数据库：查询命中10%会扫全表；索引设计；分库分表；存储异构；分页游标；表空洞释放；进度去所需列；batch insert；锁争抢分析；：
     * 缓存：redis热点key性能差； mget key数量不要超过200；key失效时间拉平打散
  - **JVM** （ 待补充）
     * vm优化相关：如果是younggc单次高，那么应该适当缩小年轻代，如果是fullgc大且频繁需要看下gc内容，优化兑现生产。
  - **代码**
     * 代码结构、边写习惯：
        * 复用度不高、扩展性不好的抽象要废弃，只有一个判定条件还用模版模式其实没有任何用户，只会多生成对象；
        * final类、方法的使用：编译器编译期优化会对final方法进行内联，其对于运行效率提升比较大。
        * 不需要重用的内容尽量采用局部变量，随方法的压栈弹出已经释放，不需要垃圾回收。
        * 集合类初始大小的使用。在可以确定集合类的大小的情况下，尽量在声明的时候就设置大小。比如HashMap的默认大小是16，如果size比较大，多次resize的成本很高。
        * 不要在循环中反复获取同一个资源，比如：(for int i =0; i < a.size(); i++),可以考虑将a.size()提取到外面或者在声明i的地方）。
        * 不要再循环内trycatch；
        * 如果可以的话，乘除算法可以考虑使用移位操作，但是这样子可读性会变差。
     * 昂贵、重复访问资源使用方式：
        * 预初始化：不论是采用静态加载，还是在构造方法里面初始化，还是采用postconstruct等注解加载，对于读取次数很多的内容，如果某单位时间内变动次数很少，或者可以采用广播、通知方式更新的内容，都可以先在内存进行初始化。
        * 懒加载：不论是接口调用，还是某些值的调用。如果在代码抽象后，需要前后访问，并且在一定条件下才可以访问，可以考虑采用lazy的方式。该情况主要应对于需要对外的调用，db、缓存、接口等都可以看情况进行。
        * 异步计算：该内容不是指多线程并发。仅仅是指某些需要计算的内容的，可以通过单独某个线程、其他应用进行计算其结果，然后逻辑直接访问，而不是每次都计算。
     * 锁争抢的缩小：
        * 线程私有变量的使用，比如threadlocalrandom、pattern（regrex）；
        * 机器之间的逻辑按照锁的维度将固定的值路由stick到固定机器，可以合并消息处理，避免分布锁的争抢；
        * 重复执行的代码进行缓存，比如int的127
    * 资源操作的合并：
       * 多insert改为batch insert；
       * redis多次get改为mget或者pipeline方式；
       * 日志、埋点上报的本地缓存，批量上报；
       * vm间需要获取分布式锁资源的操作，可以考虑vm间该锁粒度的内容都stick到同一台机器，减少锁争抢。
    * 日志打印
       * 比如接口超时日志如果仅作为指标其实可以抽样或者合并异常打印，其实对于GC的优化也有帮助。
       * 日志级别只打印需要的级别，日志过多对于高qps的应用压力非常大。
       * 打印时日志级别的判定，先ifxxxenabled，再打印，否则即便是日志级别没有那么低，其实也会先执行
       * log4j2 替换log4j等，asyncappender的使用等。
    * 多线程的合理使用：
       * 并行化调用，比如某个接口单词允许200个大小的list当入参，但是我们有1000个参数，循环5次VS并行5个线程；
       * 基本上使用线程的场景（除非是jvm钩子），一般都需要使用线程池；
       * 线程池的资源很宝贵，需要在使用的时候估计好线程数量、线程工厂、队列大小、拒绝策略等，不要随便就声明了池资源。
       * 线程间通信使用并发包的各种工具，semaphore、countdownlatch等，不要自己造全局变量再加锁。
       * 对于线程不安全但是线程内逻辑可服用的，尽量采用threadlocal变量，而不要全局变量加锁。
    * 事务缩小：
       * 主逻辑中分支逻辑进行异步化，保证最终一致性；
       * 采用消息通知等通知到细分服务逻辑，巨大的逻辑事务可以考虑拆分服务，消息通知、消息流等。
    * 缓存的使用：
       * 集群缓存引入：结果不变，vo缓存 VS 结果拼接，dao缓存；
       * 缓存qps很高的情况下，数据体拉平：序列化压力大的场景情况下，缓存可以考虑数据体的拉平缩小；
       * 合理使用redis的各种结构；
       * 锁的ttl（timetoleave）失效打散，否则集中失效会导致集群性能变差；
    * 纯内存服务（理论上性能最好的选择，但是一致性维护成本很高）：
       * 通过mq或者自己写的广播实现内存刷新；
       * 布隆过滤器的使用；
       * 计算数据体大小和vm的配置，推荐直接进入老年代；
   * IO：
      * 使用非阻塞IO，NIO的使用；
   * 异常使用：
      * 异常抛出后，vm需要调整调用堆栈，对于性能影响较大，所以要慎用异常；
      * 异常使用准确的内容，不要每个地方都是直接使用Exception捕捉。
   * 反射：
      * 若非必要，尽量少采用反射；特别是还需要通过反射去获取一个类的资源，这个操作比较重。    

